import anthropic
import os
import subprocess
import re
import logging
import tempfile
import sys
import base64
import glob
from datetime import datetime
from typing import Tuple, Optional, List, Dict, Any

##### CONFIGURATION #####

# Agent constants
MAX_ITER = 2                # Number of agent iterations
EXEC_TIMEOUT = 20           # Execution limit in seconds
AGENT_RUN_DIR = "runs"      # Parent directory for experiment runs
LOG_FILENAME = "agent.log"  # Log file for agent actions

# Model API constants
MODEL_NAME = "claude-3-5-sonnet-20240620"   # Must possess vision capabilities
MAX_TOKENS = 2048
TEMPERATURE = 0.2

# System prompts

CODE_PROMPT = """
You are an expert Python software engineer specialized in generating code for scientific experiments.
Your goal is write correct, executable Python code based on the user's request.

Instructions:
1. Respond with ONLY the required Python code
2. Enclose the entire Python code with a single ```python ... ``` markdown block
3. Do NOT include any explanations, introductory text, or concluding remarks outside the code block
4. Ensure the code is self contained or explicitly includes all necessary standard library imports.
5. The code MUST run non-interactively. Do not use `input()`.
6. Save all textual results or data generated by the experiment to a file named `results.txt` in the current working directory.
7. Save any generated plots or figures as PNG image files (e.g., `plot.png`) in the current working directory.
8. If correcting previous code based on an error, provide the complete, corrected Python code block adhering to these instructions.
"""

REQ_PROMPT = """
You are an expert Python dependency analyst. Given a Python script, your task is to identify the necessary pip installable packages and output them in a standard requirements.txt format

Instructions:
1. Analyze the import statements in the provided Python code.
2. Output ONLY the list of package names, one per line, exactly like a requirements.txt file.
3. Do NOT include any version specifiers unless explicitly requested.
4. DO NOT include any python standard libraries (e.g., os, sys, math, re, json, datetime, etc.).
5. If no external, pip-installable packages are imported, return absolutely nothing (an empty response). Do not include any explanatory text or comments.
6. DO NOT include any introductory text or concluding remarks outside the list of packages.
"""

SUMMARY_PROMPT = """
You are an expert scientific analyst. Your task is to provide a concise summary of a computational experiment based on the provided information.

Instructions:
1. Review the original request, the executed Python code, the textual results (`results.txt`), and any generated images.
2. Synthesize this information into a brief summary (~1-3 paragraphs) explaining what the experiment did and what the key results were.
3. Focus on interpreting the results in the context of the original request.
4. **Format the summary using Markdown for readability.** Use paragraphs, and consider using bullet points or bold text for key findings if appropriate.
5. Respond ONLY with the summary text in Markdown format. Do not include greetings or extraneous explanations.
"""

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    filename=LOG_FILENAME,
    filemode="w",
    force=True
)


##### HELPER FUNCTIONS #####

def get_anthropic_client() -> anthropic.Anthropic:
    """Initializes and returns the Anthropic client."""
    api_key = os.getenv("ANTHROPIC_API_KEY")
    if not api_key:
        logging.error("ANTHROPIC_API_KEY environment variable is not set.")
        raise ValueError("ANTHROPIC_API_KEY environment variable is not set.")
    try:
        client = anthropic.Anthropic(api_key=api_key)
        logging.info("Anthropic client initialized successfully.")
        return client
    except Exception as e:
        logging.error(f"Failed to initialize Anthropic client: {e}")
        raise


def extract_python_code(text: str) -> Optional[str]:
    """Extracts Python code enclosed in ```python ... ``` markdown blocks."""
    match = re.search(r"```python\n(.*?)\n```", text, re.DOTALL)
    if match:
        extracted_code = match.group(1).strip()
        logging.info("Extracted Python code block from LLM response.")
        return extracted_code
    logging.error("Failed to find Python code block in LLM response.")
    return None


def _run_subprocess(command: List[str], cwd: str, timeout: int) -> Tuple[int, str, str]:
    """Helper function to run a subprocess and capture output."""
    stdout, stderr = "", ""
    try:
        process = subprocess.run(
            command,
            capture_output=True,
            text=True,
            timeout=timeout,
            encoding="utf-8",
            errors="replace",
            cwd=cwd,
            check=False  # Don't raise exception on non-zero exit
        )
        stdout = process.stdout or ""
        stderr = process.stderr or ""
        return process.returncode, stdout, stderr
    except subprocess.TimeoutExpired as e:
        error_msg = f"Command '{' '.join(command)}' timed out after {timeout} seconds."
        logging.error(error_msg)
        stdout = e.stdout or ""
        stderr = (e.stderr or "") + f"\n{error_msg}"
        return -1, stdout, stderr # Indicate timeout with -1
    except FileNotFoundError:
        error_msg = f"File not found error during execution in {cwd}. Command: {' '.join(command)}"
        logging.error(error_msg)
        return -2, "", error_msg # Indicate file not found with -2
    except Exception as e:
        error_msg = f"Subprocess failed: {e}"
        logging.exception(error_msg) # Log exception traceback
        return -3, "", error_msg # Indicate other exceptions


def run_python_code(code: str, timeout: int, experiment_dir: str) -> Tuple[int, str, str]:
    """
    Executes Python code in a specified directory.

    Args:
        code: The Python code string to execute.
        timeout: Maximum execution time in seconds.
        experiment_dir: The directory to execute the code in.

    Returns:
        Tuple (return_code, stdout, stderr).
    """
    script_name = "main.py"
    script_path = os.path.join(experiment_dir, script_name)

    try:
        with open(script_path, "w", encoding="utf-8") as f:
            f.write(code)
        logging.info(f"Python code saved to {script_path}")
    except IOError as e:
        error_msg = f"Failed to write Python code to {script_path}: {e}"
        logging.error(error_msg)
        return -4, "", error_msg # Indicate file write error

    command = [sys.executable, script_name]
    logging.info(f"Executing command: {' '.join(command)} in {experiment_dir}")
    return_code, stdout, stderr = _run_subprocess(command, experiment_dir, timeout)

    logging.info(f"Execution finished. Return code: {return_code}")
    if stdout:
        logging.info(f"Captured Stdout:\n{stdout}")
    if stderr:
        # Log stderr as warning even on success, as it might contain important info
        logging.warning(f"Captured Stderr:\n{stderr}")

    return return_code, stdout, stderr


def install_requirements(requirements: str, timeout: int, experiment_dir: str) -> Tuple[int, str, str]:
    """
    Installs packages from a requirements string using pip.

    Args:
        requirements: String content of requirements.txt.
        timeout: Max time in seconds for the pip install command.
        experiment_dir: The directory containing requirements.txt and where to install.

    Returns:
        Tuple (return_code, stdout, stderr) from the pip process.
    """
    req_filename = "requirements.txt"
    req_path = os.path.join(experiment_dir, req_filename)

    try:
        with open(req_path, "w", encoding="utf-8") as f:
            f.write(requirements)
        logging.info(f"Requirements saved to {req_path}")
    except IOError as e:
        error_msg = f"Failed to write requirements to {req_path}: {e}"
        logging.error(error_msg)
        return -4, "", error_msg # Indicate file write error

    pip_cmd = [sys.executable, "-m", "pip", "install", "-r", req_filename]
    logging.info(f"Running pip command: {' '.join(pip_cmd)} in {experiment_dir}")
    return_code, stdout, stderr = _run_subprocess(pip_cmd, experiment_dir, timeout)

    logging.info(f"pip install finished. Return code: {return_code}")
    if return_code != 0:
        logging.error(f"pip install failed for {req_path}")
        if stderr: logging.error(f"pip stderr:\n{stderr}")
    else:
        logging.info("Requirements installed successfully.")

    return return_code, stdout, stderr


##### AGENT #####

class ExperimentAgent:
    """
    AI agent to generate, execute, refine, and summarize scientific code experiments.
    """
    def __init__(self):
        self.client = get_anthropic_client()
        self.experiment_dir: Optional[str] = None

    def _setup_experiment_directory(self) -> bool:
        """Creates a timestamped directory for the current experiment run."""
        try:
            os.makedirs(AGENT_RUN_DIR, exist_ok=True)
        except OSError as e:
            logging.error(f"Failed to create base directory {AGENT_RUN_DIR}: {e}")
            return False

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        experiment_folder_name = f"run_{timestamp}"
        self.experiment_dir = os.path.join(AGENT_RUN_DIR, experiment_folder_name)

        try:
            os.makedirs(self.experiment_dir, exist_ok=True)
            logging.info(f"Created experiment directory: {self.experiment_dir}")
            return True
        except OSError as e:
            logging.error(f"Failed to create experiment directory {self.experiment_dir}: {e}")
            self.experiment_dir = None # Reset if creation failed
            return False

    def _cleanup_previous_outputs(self):
        """Removes results.txt and *.png files from the experiment directory."""
        if not self.experiment_dir:
            return
        logging.info("Cleaning up outputs from previous iteration.")
        files_to_remove = ["results.txt"] + glob.glob(os.path.join(self.experiment_dir, "*.png"))
        for file_path in files_to_remove:
            try:
                if os.path.exists(file_path):
                    os.remove(file_path)
                    logging.info(f"Removed: {os.path.basename(file_path)}")
            except OSError as e:
                logging.warning(f"Could not remove file {file_path}: {e}")


    def _call_anthropic_api(self, system_prompt: str, messages: List[Dict[str, Any]], max_tokens: int, temperature: float) -> Optional[str]:
        """Handles calling the Anthropic API and basic response/error handling."""
        try:
            response = self.client.messages.create(
                model=MODEL_NAME,
                messages=messages,
                system=system_prompt,
                max_tokens=max_tokens,
                temperature=temperature
            )
            logging.info(f"Received response from Anthropic API (model: {MODEL_NAME}).")

            # Handle different response content types gracefully
            if response.content:
                if isinstance(response.content, list) and response.content:
                    # Common case: list of blocks, take text from the first one
                    if hasattr(response.content[0], 'text'):
                        return response.content[0].text.strip()
                    else:
                        logging.warning(f"First content block has no 'text' attribute: {response.content[0]}")
                        return str(response.content[0]) # Fallback
                elif isinstance(response.content, list) and not response.content:
                     # Empty list, e.g., for requirements if none found
                     logging.info("API returned empty content list.")
                     return ""
                else:
                    # Fallback for unexpected structures
                    logging.warning(f"Unexpected response content structure: {type(response.content)}")
                    return str(response.content).strip()
            else:
                logging.warning("API response content is empty.")
                return "" # Return empty string for empty content

        except anthropic.APIConnectionError as e:
            logging.error(f"Anthropic API connection error: {e}")
        except anthropic.RateLimitError as e:
            logging.error(f"Anthropic API rate limit exceeded: {e}")
        except anthropic.APIStatusError as e:
            logging.error(f"Anthropic API status error: {e.status_code} - {e.response}")
        except Exception as e:
            logging.exception("Anthropic API call failed unexpectedly.") # Log traceback
        return None # Indicates API call failure


    def _generate_code(self, prompt: str, previous_code: Optional[str], last_error: Optional[str], previous_summary: Optional[str]) -> Optional[str]:
        """Generates or refines Python code using Claude."""
        user_content = ""
        log_message = ""

        if last_error:
            user_content = f"The following Python code, intended to implement the experiment described below, produced an error.\nOriginal Experiment:\n{prompt}\n\nCode Attempt:\n```python\n{previous_code}\n```\n\nError Context:\n{last_error}\n\nPlease refine the Python code to fix the error AND address the original experiment request. Provide the complete, corrected Python code block only, enclosed in ```python ... ```."
            log_message = "Generating code to fix previous error."
        elif previous_code and previous_summary:
            user_content = f"The previous attempt to implement the experiment below was successful.\nOriginal Experiment:\n{prompt}\n\nPreviously Successful Code:\n```python\n{previous_code}\n```\n\nSummary of Previous Results:\n{previous_summary}\n\nPlease analyze the previous code and summary, then provide an improved version of the Python code. Aim to better address the original experiment request or enhance the previous approach based on its results. Provide the complete, improved Python code block only, enclosed in ```python ... ```."
            log_message = "Generating improved code based on previous success."
        else:
            user_content = f"Generate Python code to implement the following experiment:\n{prompt}\nRemember to only output the code within a single ```python ... ``` block."
            log_message = "Generating initial code."

        logging.info(log_message)
        messages = [{"role": "user", "content": user_content}]
        response_text = self._call_anthropic_api(CODE_PROMPT, messages, MAX_TOKENS, TEMPERATURE)

        if response_text is not None:
            extracted_code = extract_python_code(response_text)
            if not extracted_code:
                logging.error(f"Could not extract Python code from API response:\n{response_text}")
                return None
            return extracted_code
        else:
            return None # API call failed


    def _generate_requirements(self, code: str) -> Optional[str]:
        """Generates requirements.txt content based on provided code."""
        user_content = f"Based only on the import statements in the following Python code, generate a requirements.txt listing the necessary pip packages:\n```python\n{code}\n```\nOutput ONLY the requirements.txt content, one package per line."
        messages = [{"role": "user", "content": user_content}]

        logging.info("Generating requirements.txt via API.")
        response_text = self._call_anthropic_api(REQ_PROMPT, messages, max_tokens=512, temperature=0.0)
        # response_text can be None (API failure), "" (no reqs found), or string of reqs
        return response_text


    def _generate_summary(self, prompt: str, code: str) -> Optional[str]:
        """Generates an experiment summary using prompt, code, results.txt, and images."""
        if not self.experiment_dir:
             logging.error("Cannot generate summary: experiment directory not set.")
             return None

        results_content = "No results.txt file was generated or it was empty."
        results_path = os.path.join(self.experiment_dir, "results.txt")
        try:
            if os.path.exists(results_path):
                with open(results_path, "r", encoding="utf-8") as f:
                    results_content = f.read().strip()
                    if not results_content:
                        results_content = "results.txt exists but is empty."
                logging.info(f"Read {len(results_content)} bytes from {results_path}")
            else:
                logging.info(f"{results_path} not found for summary.")
        except Exception as e:
            logging.error(f"Error reading {results_path}: {e}")
            results_content = f"Error reading results.txt: {e}"

        # Construct initial message parts
        user_message_content: List[Dict[str, Any]] = [
            {"type": "text", "text": f"Please synthesize all information below (text, code, images) and summarize the following experiment.\nOriginal Request:\n{prompt}\n\nExecuted Code:\n```python\n{code}\n```\n\nTextual Results (from results.txt):\n{results_content}\n\nGenerated Images (if any) follow:"}
        ]

        # Find, encode, and append PNG images
        png_files = glob.glob(os.path.join(self.experiment_dir, "*.png"))
        logging.info(f"Found {len(png_files)} PNG files for summary in {self.experiment_dir}.")
        for i, img_path in enumerate(png_files):
            try:
                with open(img_path, "rb") as image_file:
                    image_data = base64.b64encode(image_file.read()).decode("utf-8")
                user_message_content.append({"type": "text", "text": f"Image {i+1}: {os.path.basename(img_path)}"})
                user_message_content.append({
                    "type": "image",
                    "source": {"type": "base64", "media_type": "image/png", "data": image_data}
                })
                logging.info(f"Added image {os.path.basename(img_path)} to summary request.")
            except Exception as e:
                logging.error(f"Error processing image {img_path} for summary: {e}")
                user_message_content.append({"type": "text", "text": f"Error processing image {os.path.basename(img_path)}: {e}"})


        messages = [{"role": "user", "content": user_message_content}]
        logging.info("Calling Anthropic API to generate summary.")
        summary = self._call_anthropic_api(SUMMARY_PROMPT, messages, MAX_TOKENS, TEMPERATURE)

        if summary is not None:
            logging.info("Successfully generated experiment summary.")
            return summary # Already stripped in _call_anthropic_api
        else:
            logging.error("Summary generation failed (API call error).")
            return None


    def run_experiment(self, prompt: str) -> Tuple[bool, Optional[str]]:
        """
        Runs the full experiment cycle: setup, generate, install, execute, refine, summarize.

        Args:
            prompt: Text description of the experiment.

        Returns:
            A tuple (success, experiment_dir):
            - success: True if any iteration executed successfully and generated a summary.
            - experiment_dir: Path to the run directory, or None if setup failed.
        """
        if not self._setup_experiment_directory() or not self.experiment_dir:
            return False, None

        logging.info(f"--- Starting Experiment Run in {self.experiment_dir} ---")
        logging.info(f"Original Prompt: {prompt}")

        current_code: Optional[str] = None
        last_error_context: Optional[str] = None
        last_summary: Optional[str] = None
        final_success = False
        summary_filename = os.path.join(self.experiment_dir, "summary.md") # Use markdown extension

        for attempt in range(MAX_ITER):
            logging.info(f"--- Attempt {attempt + 1} of {MAX_ITER} ---")

            # 1. Generate or Refine Code
            # Use previous summary only if last iteration succeeded (no error context)
            generated_code = self._generate_code(prompt, current_code, last_error_context, last_summary if not last_error_context else None)
            # Reset context for the next loop iteration
            last_error_context = None
            last_summary = None

            if not generated_code:
                log_msg = "Failed to generate or extract code."
                logging.error(log_msg)
                if attempt == 0: return False, self.experiment_dir # Cannot continue without initial code
                logging.warning("Continuing iteration with previous code (if available).")
                if not current_code: return False, self.experiment_dir # Should not happen if attempt > 0, but safety check
                # Keep using current_code
            else:
                current_code = generated_code # Update code for this attempt

            # 2. Generate and Install Requirements
            requirements = self._generate_requirements(current_code)
            if requirements is None:
                last_error_context = "Failed to generate requirements via API."
                logging.error(last_error_context)
                continue # Try next iteration to potentially fix code/reqs generation
            elif requirements: # Only install if requirements are not empty
                logging.info(f"Attempting to install requirements:\n{requirements}")
                install_ret_code, install_stdout, install_stderr = install_requirements(
                    requirements, EXEC_TIMEOUT * 2, self.experiment_dir # Allow more time for pip
                )
                if install_ret_code != 0:
                    logging.error("Failed to install generated requirements.")
                    last_error_context = f"Failed to install requirements.\nPip Stderr:\n{install_stderr}\nPip Stdout:\n{install_stdout}\nRequirements:\n{requirements}"
                    continue # Try next iteration
                logging.info("Requirements installed successfully.")
            else:
                logging.info("No external requirements identified or needed.")

            # 3. Cleanup previous outputs (if not first attempt)
            if attempt > 0:
                self._cleanup_previous_outputs()

            # 4. Execute Code
            logging.info("Executing generated code...")
            return_code, stdout, stderr = run_python_code(
                current_code, EXEC_TIMEOUT, self.experiment_dir
            )

            # 5. Evaluate Execution & Summarize on Success
            if return_code == 0:
                logging.info("Code execution successful.")
                final_success = True # Mark that at least one attempt succeeded
                summary = self._generate_summary(prompt, current_code)
                if summary:
                    last_summary = summary # Store for potential refinement in the next iter
                    logging.info(f"--- Generated Experiment Summary (Attempt {attempt + 1}) ---\n{summary}\n--- End Summary ---")
                    try:
                        # Append summary to the file
                        with open(summary_filename, "a", encoding="utf-8") as f:
                            f.write(f"# Summary for Attempt {attempt + 1}\n\n")
                            f.write(summary)
                            f.write("\n\n---\n\n")
                        logging.info(f"Appended summary to {summary_filename}")
                    except IOError as e:
                        logging.error(f"Failed to write summary to file: {e}")
                        # Continue, but log the failure
                else:
                    # Summary generation failed after successful execution
                    logging.error("Failed to generate summary after successful execution.")
                    last_error_context = "Execution succeeded, but failed to generate summary."
                    # Consider if we should continue or break here. Let's continue for now.
            else:
                # Execution Failed
                logging.warning(f"Code execution failed (return code: {return_code}).")
                last_error_context = f"Code execution failed.\nReturn Code: {return_code}\nStderr:\n{stderr}\nStdout:\n{stdout}"
                logging.info("Attempting to refine code based on error...")
                # Error context is set, loop will continue to _generate_code


        # End of loop
        logging.info(f"--- Finished {MAX_ITER} Iterations ---")
        if final_success:
            return True, self.experiment_dir
        else:
            if last_error_context: # Include context from the very last failed attempt
                final_msg += f"\nLast error context:\n{last_error_context}"
            logging.error(final_msg)
            return False, self.experiment_dir


if __name__ == "__main__":
    # Example Usage
    initial_prompt = "Create a classification task with non-linear data and train a neural network on it as best you can."

    print("--- Experiment Agent Started ---")
    print(f"Logging to: {LOG_FILENAME}")
    logging.info(f"Starting agent run with model: {MODEL_NAME}, Max Iter: {MAX_ITER}, Timeout: {EXEC_TIMEOUT}s")
    logging.info(f"Initial Prompt: {initial_prompt}")

    agent = ExperimentAgent()
    try:
        success, run_directory = agent.run_experiment(initial_prompt)

        if success and run_directory:
            final_message = f"Agent run completed successfully. Check results in: {run_directory}"
            print(final_message)
            logging.info(final_message)
        else:
            final_message = f"Agent run failed or did not succeed within {MAX_ITER} attempts."
            if run_directory:
                final_message += f" Check logs and artifacts in: {run_directory}"
            else:
                final_message += f" Check {LOG_FILENAME} for setup errors."
            print(final_message)
            logging.error(final_message)

    except Exception as e:
        logging.exception("Critical error during agent execution.") # Log traceback
        print(f"A critical error occurred. Check {LOG_FILENAME} for details.")

    finally:
        print("--- Experiment Agent Finished ---")
    