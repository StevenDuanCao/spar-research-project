import anthropic
import os
import subprocess
import re
import logging
import tempfile
import sys
from datetime import datetime
import time
import select
import glob
import base64

##### CONFIGURATION #####

# Agent configurations
MAX_ITER = 1
EXEC_TIMEOUT = 20
MAX_TOKENS = 2048
TEMPERATURE = 0.2
AGENT_RUN_DIR = "runs"                      # Parent directory for experiment runs
LOG_FILENAME = "agent.log"                  # Log file for agent actions
MODEL_NAME = "claude-3-5-sonnet-20240620"

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    filename=LOG_FILENAME,
    filemode="w",
    force=True
)

##### SYSTEM PROMPTS ######

CODE_PROMPT = """
You are an expert Python software engineer specialized in generating code for scientific experiments.
Your goal is write correct, executable Python code based on the user's request.

Instructions:
1. Respond with ONLY the required Python code
2. Enclose the entire Python code with a single ```python ... ``` markdown block
3. Do NOT include any explanations, introductory text, or concluding remarks outside the code block
4. Ensure the code is self contained or explicitly includes all necessary standard library imports.
5. The code MUST run non-interactively. Do not use `input()`.
6. Save all textual results or data generated by the experiment to a file named `results.txt` in the current working directory.
7. Save any generated plots or figures as PNG image files (e.g., `plot.png`) in the current working directory.
8. If correcting previous code based on an error, provide the complete, corrected Python code block adhering to these instructions.
"""

REQ_PROMPT = """
You are an expert Python dependency analyst. Given a Python script, your task is to identify the necessary pip installable packages and output them in a standard requirements.txt format

Instructions:
1. Analyze the import statements in the provided Python code.
2. Output ONLY the list of package names, one per line, exactly like a requirements.txt file.
3. Do NOT include any version specifiers unless explicitly requested.
4. DO NOT include any python standard libraries (e.g., os, sys, math, re, json, datetime, etc.).
5. If no external, pip-installable packages are imported, return absolutely nothing (an empty response). Do not include any explanatory text or comments.
6. DO NOT include any introductory text or concluding remarks outside the list of packages.
"""

SUMMARY_PROMPT = """
You are an expert scientific analyst. Your task is to provide a concise summary of a computational experiment based on the provided information.

Instructions:
1. Review the original request, the executed Python code, the textual results (`results.txt`), and any generated images.
2. Synthesize this information into a brief summary (~1-3 paragraphs) explaining what the experiment did and what the key results were.
3. Focus on interpreting the results in the context of the original request.
4. **Format the summary using Markdown for readability.** Use paragraphs, and consider using bullet points or bold text for key findings if appropriate.
5. Respond ONLY with the summary text in Markdown format. Do not include greetings or extraneous explanations.
"""

##### HELPER FUNCTIONS #####

def get_anthropic_client() -> anthropic.Anthropic:
    """
    Initializes Anthropic client using API key
    """
    api_key = os.getenv("ANTHROPIC_API_KEY")
    if not api_key:
        raise ValueError("ANTHROPIC_API_KEY environment variable is not set")
    try:
        client = anthropic.Anthropic(api_key=api_key)
        logging.info("Anthropic client initialized successfully")
        return client
    except Exception as e:
        logging.error(f"Failed to initialize Anthropic client: {e}")
        raise
    
def extract_python_code(text: str) -> str | None:
    """
    Extracts Python code from markdown text
    """
    # Look for ```python ... ``` blocks
    python_block = r"```python\n(.*?)```"
    matches = re.findall(python_block, text, re.DOTALL)
    if matches:
        extracted = matches[0].strip()
        logging.info("Extracted Python block from LLM response")
        return extracted
    logging.error("Failed to find Python block in LLM response")
    return None

def run_python_code(code: str, timeout: int, experiment_dir: str) -> tuple[int, str, str]:
    """
    Executes given Python code string in a temporary file using a subprocess
    
    Args:
        code: The Python code to execute
        timout: Maximum execution time in seconds
        
    Returns:
        A tuple (return_code, stdout, stderr):
        - return_code: The exit code of the subprocess
        - stdout: The standard output of the script
        - stderr: The standard error of the script or execution error message
    """
    script_name = "main.py"
    script_path = os.path.join(experiment_dir, script_name)
    stdout, stderr = "", ""
    
    try:
        # Write code to script file
        with open(script_path, "w", encoding="utf-8") as script_file:
            script_file.write(code)
            script_file.flush()
        logging.info(f"Executing generated code in file {script_path}")
        
        # Execute using same Python interpreter running this script
        process = subprocess.run(
            [sys.executable, script_name],
            capture_output=True,
            text=True,
            timeout=timeout,
            encoding="utf-8",
            errors="replace",
            cwd=experiment_dir,
            check=False # Don't raise exception on non-zero exit
        )
        
        stdout = process.stdout
        stderr = process.stderr
        return_code = process.returncode
        
        logging.info(f"Execution finished with return code: {return_code}")
        if stdout:
            logging.info(f"Captured Stdout:\n{stdout}")
        if stderr:
            # Log stderr as warning regardless of return code
            logging.warning(f"Captured Stderr:\n{stderr}")

        return return_code, stdout, stderr
    
    # Handle exceptions
    except subprocess.TimeoutExpired as e:
        error_msg = f"Code execution timed out after {timeout} seconds."
        logging.error(error_msg)
        # Capture any output that was produced before timeout
        stdout = e.stdout if e.stdout else ""
        stderr = e.stderr if e.stderr else error_msg
        if stdout:
             logging.info(f"Captured Stdout (before timeout):\n{stdout}")
        logging.error(f"Captured Stderr (before timeout):\n{stderr}")
        return -1, stdout, stderr
    except FileNotFoundError:
        error_msg = f"File not found error during execution in {experiment_dir}. Interpreter: {sys.executable}"
        logging.error(error_msg)
        return -2, "", error_msg
    except Exception as e:
        error_msg = f"Failed to run subprocess: {e}"
        logging.exception(error_msg)
        return -1, "", error_msg

def install_requirements(requirements: str, timeout: int, experiment_dir: str) -> tuple[int, str, str]:
    """
    Install packages from a requirements string using pip
    
    Args: 
        requirements: string content of requirements.txt file
        timeout: max time in seconds for pip install command
    
    Returns: 
        A tuple (return_code, stdout, stderr) from the pip process
    """
    req_filename = "requirements.txt"
    req_path = os.path.join(experiment_dir, req_filename)
    stdout, stderr = "", ""
    try:
        # Write requirements to requirements.txt
        with open(req_path, "w", encoding="utf-8") as req_file:
            req_file.write(requirements)
            req_file.flush()
        logging.info(f"Installing requirements from file {req_path}")
        
        # Execute pip install command
        pip_cmd = [sys.executable, "-m", "pip", "install", "-r", req_filename]
        logging.info(f"Running pip command: {' '.join(pip_cmd)}")
        process = subprocess.run(
            pip_cmd,
            capture_output=True,
            text=True,
            check=False, # Don't raise exception on non-zero exit
            timeout=timeout,
            encoding="utf-8",
            cwd=experiment_dir # Set current working directory
        )
        
        stdout = process.stdout
        stderr = process.stderr
        logging.info(f"pip install finished. Return code: {process.returncode}")
        if process.returncode != 0:
            logging.error(f"pip install failed for {req_path}")
            logging.error(f"pip stderr:\n{stderr}")
            logging.error(f"pip stdout:\n{stdout}")
        return process.returncode, stdout, stderr
    
    except Exception as e:
        error_msg = f"Failed to install requirements: {e}"
        logging.exception(error_msg)
        if not stderr:
            stderr = error_msg
        return -1, stdout, stderr
    
class ExperimentAgent:
    """
    An AI agent that takes an experiment description, generates Python code using
    Claude, executes it, and iteratively refines the code based on execution errors
    until success or max retries is reached. 
    """
    def __init__(self):
        self.client = get_anthropic_client()
        self.experiment_dir = None
    
    def run_experiment(self, prompt: str) -> tuple[bool, str | None]:
        """
        Executes the full code cycle: generating, running, refining, and summarizing.
        
        Args:
            prompt: Text description of experiment
        
        Returns:
            A tuple (success, experiment_dir):
            - success: True if code executed successfully and summary generated, False otherwise.
            - experiment_dir: The path to the experiment run directory if successful, None otherwise.
        """
        # Ensure the parent agent_runs directory exists
        try:
            os.makedirs(AGENT_RUN_DIR, exist_ok=True)
            logging.info(f"Ensured parent directory exists: {AGENT_RUN_DIR}")
        except OSError as e:
             logging.error(f"Failed to create parent directory {AGENT_RUN_DIR}: {e}")
             return False, None, f"Failed to create base directory {AGENT_RUN_DIR}: {e}"
        # Create timestamped directory for this experiment run inside AGENT_RUNS_DIR
        timestamp = datetime.now().isoformat(timespec='seconds')
        experiment_folder_name = f"run-{timestamp}"
        # Store the full path
        self.experiment_dir = os.path.join(AGENT_RUN_DIR, experiment_folder_name) 
        try:
            os.makedirs(self.experiment_dir, exist_ok=True) 
            logging.info(f"Created experiment directory: {self.experiment_dir}")
        except OSError as e:
             logging.error(f"Failed to create directory {self.experiment_dir}: {e}")
             return False, None, f"Failed to create directory {self.experiment_dir}: {e}"
        
        logging.info(f"Starting experiment")
        current_code = None
        last_error_context = None 
        last_summary = None
        final_success = False # Track if any iteration succeeded
        last_stdout = None
        summary_filename = os.path.join(self.experiment_dir, "summary.txt")
        
        for attempt in range(MAX_ITER):
            logging.info(f"--- Attempt {attempt + 1} of {MAX_ITER} ---")
            
            # 1. Generate or refine code
            # Pass previous summary if last attempt succeeded, otherwise pass error context
            generated_code = self._generate_code(
                prompt, 
                current_code, 
                last_error_context,
                last_summary if not last_error_context else None
                )
            # Clear previous state for next iteration input
            last_error_context = None
            last_summary = None
            
            if not generated_code:
                fail_msg = "Failed to generate or extract code from API"
                logging.error(fail_msg)
                # If happens on first attempt, we can't continue
                if attempt == 0 or not current_code:
                    return False, None, fail_msg
                # Otherwise, try to continue with previous code if available
                logging.warning("Proceeding with code from previous attempt")
                continue
            
            current_code = generated_code
            logging.info("Generated code for current attempt")
            
            # 2. Generate and install requirements
            requirements = self._generate_requirements(current_code)
            
            # Check requirements content before attempting install
            if requirements is None:
                # Case 1: generate requirements failed
                last_error_context = "Failed to generate requirements.txt content"
                logging.error(last_error_context)
                continue
            else:
                # Case 2: requirements generated
                logging.info("Attempting to install requirements...")
                install_ret_code, install_stdout, install_stderr = install_requirements(
                    requirements, EXEC_TIMEOUT, self.experiment_dir
                )
                if install_ret_code == 0:
                    logging.info("Requirements installed successfully for this attempt")
                else:
                    # Failed to install requirements
                    logging.error("Failed to install generated requirements")
                    last_error_context = f"""
                        Failed to install generated requirements:
                        Pip Stderr:\n{install_stderr}\n
                        Pip Stdout:\n{install_stdout}\n
                        Generated requirements.txt:\n{requirements}\n
                    """
                    # Continue to next attempt to try to fix
                    continue
            
            # 2.5. Cleanup before execution (only after first attempt)
            if attempt > 0:
                logging.info(f"Cleaning up outfiles from previous iteration")
                # Delete results.txt
                results_path = os.path.join(self.experiment_dir, "results.txt")
                try:
                    if os.path.exists(results_path):
                        os.remove(results_path)
                        logging.info(f"Removed previous results file: {results_path}")
                except OSError as e:
                    logging.warning(f"Could not remove previous results file {results_path}: {e}")
                # Delete *.png files
                png_pattern = os.path.join(self.experiment_dir, "*.png")
                previous_pngs = glob.glob(png_pattern)
                if previous_pngs:
                    logging.info(f"Found {len(previous_pngs)} PNG file(s) from previous attempt to remove.")
                    for png_file in previous_pngs:
                        try:
                            os.remove(png_file)
                            logging.info(f"Removed previous PNG file: {png_file}")
                        except OSError as e:
                            logging.warning(f"Could not remove previous PNG file {png_file}: {e}")
                else:
                    logging.info("No previous PNG files found to remove.")
            
            # 3. Execute generated code
            logging.info("Running generated code...")
            return_code, stdout, stderr = run_python_code(
                current_code, EXEC_TIMEOUT, self.experiment_dir
            )
            last_stdout = stdout
            
            # 4. Evaluate execution result
            if return_code == 0: 
                # Success
                logging.info("Code execution successful")
                final_success = True
                
                # 5. Generate summary
                logging.info("Attempting to generate experiment summary...")
                summary = self._generate_summary(prompt, current_code)
                if summary:
                    last_summary = summary
                    logging.info(f"--- Generated Experiment Summary ---\n{summary}\n")
                    summary_filename = os.path.join(self.experiment_dir, "summary.txt")
                    try:
                        # Append summary to the file
                        with open(summary_filename, "a", encoding="utf-8") as f:
                            f.write(f"--- Summary for Attempt {attempt + 1} ---\n")
                            f.write(summary)
                            f.write("\n\n")
                        logging.info(f"Appended summary to {summary_filename}")
                    except IOError as e:
                        logging.error(f"Failed to append summary to file: {e}")
                        last_error_context = "Failed to generate summary after successful exection"
                else:
                    error_msg = "Failed to generate summary after successful exection"
                    logging.error(error_msg)
                    last_error_context = error_msg
            else:
                # Failure: prepare error context for next generation attempt
                last_error_context = f"Code execution failed for attempt {attempt+1}\n"
                logging.warning(last_error_context)
                if stderr:
                    last_error_context += f"Stderr:\n{stderr}\n"
                else:
                    last_error_context += "No output on stderr\n"
                if stdout:
                    last_error_context += f"Stdout:\n{stdout}\n"
                logging.info("Attempting to refine code based on error...")
        
        # Max retries reached
        logging.info(f"Finished {MAX_ITER} iterations")
        if final_success:
            final_msg = f"Agent finished. At least one iteration succeeded."
            logging.info(final_msg)
            return True, self.experiment_dir
        else:
            final_msg = f"Agent failed after {MAX_ITER} attempts"
            if last_error_context:
                final_msg += f"\nLast error:\n{last_error_context}"
            if last_stdout:
                final_msg = f"\nLast stdout:\n{last_stdout}"
            logging.error(final_msg)
            return False, self.experiment_dir
        
    def _generate_code(self, prompt: str, previous_code: str, last_error: str, previous_summary: str | None) -> str | None:
        """
        Generates or refines Python code using Claude.

        Args:
            prompt: The original experiment description.
            previous_code: The code from the previous attempt (if any).
            last_error: The error context from the previous failed execution (if any).
            previous_summary: The summary from the previous successful execution (if any).

        Returns:
            The extracted Python code string, or None if API call or extraction fails.
        """
        if last_error:
            # Code refinement request based on error
            user_content = f"""
                The following Python code, intended to implement the experiment described below, produced an error.
                Original Experiment:\n{prompt}\n\n
                Code Attempt:\n```python\n{previous_code}\n```\n\n
                Error Context:\n{last_error}\n\n
                Please refine the Python code to fix the error AND address the original experiment request.
                Provide the complete, corrected Python code block only, enclosed in ```python ... ```.
            """
            logging.info("Generating code to fix the previous error.")
        elif previous_code and previous_summary:
            # Code refinement based on previous successful iteration
            user_content = f"""
                The previous attempt to implement the experiment below was successful.
                Original Experiment:\n{prompt}\n\n
                Previously Successful Code:\n```python\n{previous_code}\n```\n\n
                Summary of Previous Results:\n{previous_summary}\n\n
                Please analyze the previous code and summary, then provide an improved version of the Python code.
                Aim to better address the original experiment request or enhance the previous approach based on its results.
                Provide the complete, improved Python code block only, enclosed in ```python ... ```.
            """
            logging.info("Generating code to improve on the previous successful version.")
        else:
            # Initial code generation request
            user_content = f"""
                Generate Python code to implement the following experiment:
                {prompt}
                Remember to only output the code within a single ```python ... ``` block.
            """
            logging.info("Generating initial code.")
            
        messages = [{"role": "user", "content": user_content}]
        
        try:
            # Call Anthropic API
            response = self.client.messages.create(
                model=MODEL_NAME,
                messages=messages,
                system=CODE_PROMPT,
                max_tokens=MAX_TOKENS,
                temperature=TEMPERATURE
            )
            logging.info("Received response from Anthropic API")
            
            # Extract text from response
            response_text = ""
            if response.content and isinstance(response.content, list):
                 # Assume code is in the first block
                response_text = response.content[0].text
            else:
                logging.warning(f"Unexpected response structure: {response}")
                # Attempt to convert to string as fallback
                response_text = str(response.content)
                
            # Extract Python code from text
            extracted_code = extract_python_code(response_text)
            if not extracted_code:
                logging.error(f"Could not extract Python code from API response:\n{response_text}")
                return None
            return extracted_code

        # Handle API errors and exceptions
        except anthropic.APIConnectionError as e:
            logging.error(f"Anthropic API connection error: {e}")
        except anthropic.RateLimitError as e:
            logging.error(f"Anthropic API rate limit exceeded: {e}")
        except anthropic.APIStatusError as e:
            logging.error(f"Anthropic API status error: {e.status_code} - {e.response}")
        except Exception as e:
            logging.exception(f"Anthropic API call failed unexpectedly: {e}")
        return None
    
    def _generate_requirements(self, code: str) -> str | None:
        """
        Asks LLM to generate requirements.txt content based on the code provided
        """
        user_content = f"""
            Based only on the import statements in the following Python code, generate a requirements.txt listing the necessary pip packages:
            \n{code}\n
            Output ONLY the requirements.txt content, one package per line. 
        """
        messages = [{"role": "user", "content": user_content}]
        try:
            logging.info("Generating requirements.txt via API")
            response = self.client.messages.create(
                model=MODEL_NAME,
                max_tokens=512,
                messages=messages,
                system=REQ_PROMPT,
                temperature=0.0
            )
            response_text = ""
            if isinstance(response.content, list) and response.content:
                 # Assume code is in the first block
                response_text = response.content[0].text
            elif isinstance(response.content, list) and not response.content:
                # Content is an empty list [], means no requirements found by LLM
                logging.info("API returned empty content list, indicating no requirements needed.")
                response_text = ""
            else:
                logging.warning(f"Unexpected response structure: {response}")
                # Attempt to convert to string as fallback
                response_text = str(response.content)
            logging.info("Recieved requirements response from API")
            return response_text
        except Exception as e:
            logging.exception(f"Failed to generate requirements via API: {e}")
            return None
        
    def _generate_summary(self, prompt: str, code: str) -> str | None:
        """
        Generates a summary of the experiment using the prompt, code, results.txt, and images
        """
        results_content = ""
        
        # 1. Read results.txt
        results_path = os.path.join(self.experiment_dir, "results.txt")
        try:
            if os.path.exists(results_path):
                with open(results_path, "r", encoding="utf-8") as f:
                    results_content = f.read()
                logging.info(f"Read {len(results_content)} bytes from {results_path}")
            else:
                logging.error(f"{results_path} not found")
        except Exception as e:
            logging.error(f"Error reading {results_path}: {e}")
            
        # 2. Construct initial part of API message
        user_message_content = [
            {
                "type": "text",
                "text": f"""Please synthesize all information below (text, code, images) and summarize the following experiment.
Original Request:
{prompt}

Executed Code:
```python
{code}
```

Textual Results (from results.txt):
{results_content if results_content else "No results.txt file was generated or it was empty."}

Generated Images (if any) follow:
                """
            }
        ]
        
        # 3. Find, prepare, and append PNG images
        png_pattern = "*.png"
        png_files = glob.glob(os.path.join(self.experiment_dir, png_pattern))
        logging.info(f"Found {len(png_files)} PNG files for summary")
        
        for i, img_path in enumerate(png_files):
            try:
                with open(img_path, "rb") as image_file:
                    image_bytes = image_file.read()
                base64_image = base64.b64encode(image_bytes).decode("utf-8")
                media_type = "image/png"
                # Add text block describing image
                user_message_content.append({
                    "type": "text",
                    "text": f"Image {i+1}: {os.path.basename(img_path)}"
                })
                # Add the image block
                user_message_content.append({
                    "type": "image",
                    "source": {
                        "type": "base64",
                        "media_type": media_type,
                        "data": base64_image
                    }
                })
                logging.info(f"Prepared image {os.path.basename(img_path)} for summary")
            except Exception as e:
                logging.error(f"Error processing image {os.path.basename(img_path)}: {e}")
        
        messages = [{"role": "user", "content": user_message_content}]
        
        # 4. Call API
        try:
            logging.info("Calling Anthropic API to generate summary")
            response = self.client.messages.create(
                model=MODEL_NAME, # Ensure this model supports vision
                max_tokens=MAX_TOKENS, 
                messages=messages,
                system=SUMMARY_PROMPT,
                temperature=TEMPERATURE 
            )
            summary = ""
            if response.content and isinstance(response.content, list):
                 # Assume summary is in first block
                summary = response.content[0].text
            else:
                logging.warning(f"Unexpected response structure: {response}")
                # Attempt to convert to string as fallback
                summary = str(response.content)
            logging.info("Successfully generated experiment summary")
            return summary.strip()

        except Exception as e:
            logging.exception(f"Summary API call failed: {e}")
        return None
            

if __name__ == "__main__":
    # Get prompt
    prompt = "Generate a non-linear data and train a neural network on it as best as you can."
    # prompt = "Generate and test an algorithm that efficiently checks if a number is prime"
    
    # Log the start and the log file being used
    print(f"--- Experiment Agent Started ---")
    logging.info(f"Using model: {MODEL_NAME}, Max Iterations: {MAX_ITER}, Timeout: {EXEC_TIMEOUT}s")
    
    try:
        # Run agent
        agent = ExperimentAgent()
        success, run_dir = agent.run_experiment(prompt)
        
        # Final status message
        if success and run_dir:
            final_msg = f"Agent run completed. Check {run_dir} for details"
            logging.info(final_msg)
        else:
            final_msg = f"Agent run failed. Check {LOG_FILENAME} for action history."
            logging.error(final_msg)
        print(final_msg)
            
    except Exception as e:
        logging.error(f"Critical error during agent run: {e}")
        
    finally:
        print(f"--- Experiment Agent Finished ---")
    